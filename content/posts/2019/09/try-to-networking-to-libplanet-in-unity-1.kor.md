---
title: "Unity에서 Libplanet과 통신하기 - 1"
date: 2019-09-24
authors: [hyun.seungmin]
---

안녕하세요. 플라네타리움에서 게임을 만들고 있는 현승민입니다. 이번 글에서는 일반적인 `클라이언스-서버`구조가 아닌 `클라이언트-노드`구조를 이루고 있는 Unity와 Libplanet의 관계 위에서, Libplanet의 철학에 맞는 통신을 하되 Unity의 입맛에 맛게 활용하는 방법을 찾아가는 이야기를 소개해드릴게요. 아래의 내용은 전적으로 경험에 기반한 내용이라는 것을 감안해 주세요.

먼저 `클라이언트-서버`구조에 대해서 이야기해 볼게요. 저는 대부분의 프로젝트에서 `클라이언트-서버`구조 위에서 개발을 했어요. 당연하게도 통신을 위해서 프로토콜을 작성했는데, 이 프로토콜은 웹통신의 그것과 비슷하게 디자인했어요. 클라이언트 측에서 요청을 만들어 서버에 넘기면 서버 측에서 응답을 만들어서 클라이언트로 돌려주는 구조이죠. 요청은 주로 유저가 입력한 값을 포함 했고, 응답은 프로토콜의 성패 정보를 담는 에러코드와 요청에 의해 영향을 받은 상태 값(이하 변경점)을 포함 했어요.(골드를 사용하는 구매 요청에 대한 응답에 구매 후 남은 골드량을 포함하는 등) 물론 클라이언트 측에서 예측 가능한 변경점은 응답에 포함하지 않아도 되었죠. 간혹 응답에 에러코드만 포함하는 프로토콜들이 있었는데, 채팅과 같이 단방향으로 브로드캐스트를 수행하는 것을 예로 들 수 있겠네요. 한 프로젝트에서는 소켓으로 요청만 보내고 응답을 기다리지 않았는데, 이는 요청이 무조건 성공하도록 서버 측에서 보장해준 경우였어요.

다음은 지금 제가 개발하는 환경인 `클라이언트-노드`구조를 살펴 볼게요. Libplanet에서는 위에서 언급한 프로토콜을 `IAction` 인터페이스를 구현한 클래스(이하 액션)로 작성해요. 클라이언트 측에서 요청을 만들어 노드에 넘기면 노드 측에서 각 요청의 `Render`(이하 랜더)와 `Unrender`(이하 언랜더) 단계를 수행하는데, 클라이언트 측은 이 단계를 구독해서 `요청이 수행되었다`거나 `그 수행이 취소되었다(롤백)`는 상태를 알 수 있는 구조이죠.

언뜻 비슷한 구조로 보일 수 있지만, 전자에서는 요청과 응답이 분리되어 있어서 응답이 요청의 상태 정보(성패, 실패 했다면 그 자세한 이유)는 물론 변경점까지 포함될 수 있는데, 후자에서는 요청 하나만 존재하고 요청의 상태 정보(랜더 혹은 언랜더 여부)만 알 수 있다는 차이가 있어요. 대신에 각 요청의 랜더, 언랜더 단계에서는 해당 `요청의 전후 상태`를 알 수 있도록 인터페이스를 제공하고 있어요.

위의 내용들은 제게 몇가지 고민을 만들어 주었어요.

## 1. 변경점은 어떻게 알 수 있을까?

### 1.1. 요청의 전후 상태 비교하기

처음 든 생각은 요청의 전후 상태를 비교해서 변경점을 뽑아 내는 방법이었어요. 하지만, 블록에 직렬화되어 있는 정보를 역직렬화와 캐스팅을 통해서 상태값 A와 B를 만들어 내고, 그 둘을 비교하는 과정을 매 랜더, 언랜더 단계에서 수행하는 것이 성능에 무리가 생길 것이라는 걱정이 생겼어요. A와 B는 계정의 전체 정보를 담고 있기에 덩치가 컸고, 앞으로 더 커질 여지가 다분했기 때문이었죠.

### 1.2 변경점을 각 액션에 포함 시키기

이 방법이면 기존 구조를 변경하지 않는 선에서 목표를 완수할 수 있겠다는 착각 속에서 액션들을 척척 작성해가고 있었어요. 모든 것이 원하는 대로 잘 돌아가는 줄로만 알고 있었던 어느 날, 이제까지의 테스트가 싱글 노드에서 진행되었고 멀티 노드 환경에서는 문제가 생길 거라는 것을 알게 되었죠.

네트워크에 참여하는 모든 노드가 동일하게 액션을 처리하고 이를 전파 받더라도 동일한 액션을 보장해주는 인터페이스가 바로 `IAction.PlaneValue` 속성과 `IAction.LoadPlainValue()` 함수예요. 싱글 노드에서는 얼렁뚱땅 되는 것 처럼 보였어도 멀티 노드에서 잘 되려면 변경점을 위 두 부분에 포함시켜야 되는 현실을 깨달은 것이죠. 그렇다고 진짜 포함시키면(저는 진짜 그냥 단순히 포함시켜 봤어요) `InvalidTxSignatureException` 예외가 발생해요. 이것은 액션의 상태가 바뀔 때 발생하는데, 당연한 것이 변경점은 요청을 만들 때는 비어있고 요청이 수행된 이후에 채워지기 때문이죠. 이 과정에서 `액션의 상태는 바뀌지 않도록 작성한다`는 깨달음을 얻었어요.

그렇다면 요청을 만들 때 `예측 가능한 변경점`을 포함시키면 되지 않을까 생각했어요. 이것은 클라이언트가 만들어준 값을 노드가 믿는 구조가 되기 때문에 해킹에 용이해서 3초 만에 머리 속에서 지웠죠. 하지만 그 `예측 가능한 변경점`을 액션 내에서 검증할 수 있다면 가능하겠다는 생각이 드네요!? 그래서 엔진팀에 문의해 봤더니 엔진에서 제공하는 랜덤 객체가 완전히 공정하기 때문에 `예측 가능한 변경점`은 존재하지 않는다는 감동만이 남았네요. 감동.

### 1.3 변경점을 각 계정에 포함 시키기

이 방법도 괜찮아 보였어요. 요청의 주체는 계정이고(사이너가 계정), 요청의 변경점을 계정의 상태에 포함시키면 구조 변경 없이 목표를 완수할 수 있지 않을까 하는 기대를 갖고 액션들을 척척 작성해가고 있었어요. 계정의 상태에는 각 액션의 변경점들이 쌓이기 시작했고, 클라이언트는 특정 액션의 랜더 단계에서 계정의 상태가 포함하고 있는 특정 액션의 변경점을 참조하는 방법을 사용했죠. 이미 한 번 계산되는 변경점을 다시 계산할 필요가 없어졌고, 변경점의 참조 타이밍도 확보되어 있어서 클라이언트 개발이 순조로웠어요. 하지만 문제는 생기기 마련이었죠.

*계정 상태에 쌓이는 변경점의 생명주기는 어떻게 관리할 것인가?*

상태의 변경은 액션을 통해서만 이루어지는 특성상, 더 이상 필요가 없는 변경점을 제거하기 위해서는 별도의 액션으로 처리해야 했어요. A액션의 변경점을 참조하기 위해 상태를 변경했는데, 필요 없는 변경점을 제거하기 위해 B액션을 사용할 때, 그 변경점은 다시 상태에 담겨야 하는가? 네, 로직에 예외가 생기더라고요. 이 안은 보류했어요.

### 1.4 현재 상태
이 글을 작성하는 동안에도 Libplanet은 꾸준히 강력해졌어요. 액션의 실행 단계에서 확보되는 `IActionContext`형 인자는 액션의 상태와 무관하게 모든 노드에서 같은 결과를 결정적으로 확보할 수 있도록 몇 가지 인터페이스를 제공하고 있는데, 대표적으로 `IRandom`형 객체가 있어요. 유니티에서 제공하는 랜덤 객체는 모든 노드에서 같은 결과를 얻을 수 없지만, `IRandom`형 객체는 이것을 보장해주고 있어요.

----

다음 글에서는 `IRandom`인터페이스를 활용한 내용과 액션의 자세한 에러코드를 확보하는 것에 대해서 이야기해 볼게요.
